# gol_key_env.py

import random
import sys
from pathlib import Path
from collections import deque
import torch

import numpy as np

try:
    import gymnasium as gym
    from gymnasium import spaces
except ImportError as e:  # pragma: no cover
    raise ImportError("Gymnasium is required: pip install gymnasium") from e

# ---------------------------------------------------------------------------
# Pillow import for nicer rendering
# ---------------------------------------------------------------------------
try:
    from PIL import Image, ImageDraw, ImageFont

    PIL_AVAILABLE = True
    # Attempt to load a monospace font; fallback to default
    try:
        FONT_PATH = next(p for p in (
            "/usr/share/fonts/truetype/dejavu/DejaVuSansMono.ttf",
            "/Library/Fonts/Courier New.ttf",
            str(Path(__file__).with_suffix(".ttf")),  # local override
        ) if Path(p).exists())
        _DEFAULT_FONT = ImageFont.truetype(FONT_PATH, 12)
    except StopIteration:
        _DEFAULT_FONT = ImageFont.load_default()
except ImportError:
    PIL_AVAILABLE = False

# ---------------------------------------------------------------------------
# fast Pillow‑free renderer text
# ---------------------------------------------------------------------------
# load once – <2 kB – generated by tools/make_glyphs.py
_GLYPHS = np.load(Path(__file__).with_name("glyphs.npy"), allow_pickle=True).item()

_COLORS = np.array([
    (254,253,251), (248,188, 80), (250,181,112),
    (246, 72, 65), (223, 69, 64), (227, 26, 93),
    (131, 26, 56), ( 62,131,159), ( 75,217,231),
], dtype=np.uint8)
_BG = np.array([30, 30, 30], np.uint8)

LETTERS = "abcdefghijklmnopqrstuvwxyz "  # 26 letters + space

try:
    from numba import njit, prange
    NUMBA_OK = True
except ModuleNotFoundError:
    NUMBA_OK = False

if NUMBA_OK:
    from numba import njit

    @njit(cache=True, fastmath=True)
    def life_kernel(alive, immortal, chars, prefix_len, age,
                    typed_idx, first_letter_idx, tgt_array):
        """
        Pure‑scalar kernel:
        * no NumPy helpers
        * no fancy indexing
        * no boolean arithmetic
        Works on a 32×32 board in micro‑seconds once compiled.
        """
        H, W   = alive.shape
        tgt_len = tgt_array.size

        # ---------------- neighbour count --------------------------
        neigh = [[0]*W for _ in range(H)]
        for y in range(H):
            ym = (y - 1) % H
            yp = (y + 1) % H
            for x in range(W):
                xm = (x - 1) % W
                xp = (x + 1) % W
                cnt = 0
                # eight neighbours (toroidal)
                cnt += alive[ym][xm];  cnt += alive[ym][x];  cnt += alive[ym][xp]
                cnt += alive[y ][xm];                    cnt += alive[y ][xp]
                cnt += alive[yp][xm];  cnt += alive[yp][x];  cnt += alive[yp][xp]
                neigh[y][x] = cnt

        # ---------------- first pass: state transitions ------------
        next_alive = [[False]*W for _ in range(H)]
        for y in range(H):
            for x in range(W):
                a   = alive[y][x]
                imm = immortal[y][x]
                n   = neigh[y][x]

                born    = (not a) and n == 3
                survive = a and (n == 2 or n == 3)
                next_alive[y][x] = survive or born or imm

                # age
                if next_alive[y][x]:
                    age[y][x] += 1
                else:
                    age[y][x]  = 0
                if born:
                    age[y][x]  = 0

        # ---------------- chars & prefix ---------------------------
        if typed_idx >= 0:
            # newborns get typed char
            for y in range(H):
                for x in range(W):
                    if next_alive[y][x] and not alive[y][x]:
                        chars[y][x] = typed_idx
                        if typed_idx == first_letter_idx:
                            prefix_len[y][x] = 1

        # reset dead non‑immortals
        for y in range(H):
            for x in range(W):
                if (not next_alive[y][x]) and alive[y][x] and (not immortal[y][x]):
                    chars[y][x]      = -1
                    prefix_len[y][x] = 0

        # prefix extension & immortalisation
        if typed_idx >= 0:
            for y in range(H):
                for x in range(W):
                    if not next_alive[y][x]:
                        continue
                    ch  = chars[y][x]
                    if ch < 0:
                        continue
                    pre = prefix_len[y][x]

                    if pre == tgt_len:          # already full word
                        immortal[y][x] = True
                        continue

                    for dy, dx in ((0,1),(0,-1),(1,0),(-1,0)):
                        ny = (y + dy) % H
                        nx = (x + dx) % W
                        if not next_alive[ny][nx]:
                            continue

                        n_pre = prefix_len[ny][nx]
                        n_ch  = chars[ny][nx]

                        # Case A
                        if n_pre and n_pre < tgt_len and ch == tgt_array[n_pre]:
                            prefix_len[y][x] = n_pre + 1
                            immortal[y][x]   = True
                            immortal[ny][nx] = True
                            break
                        # Case B
                        if pre == 1 and n_ch == tgt_array[pre]:
                            prefix_len[ny][nx] = pre + 1
                            immortal[y][x]     = True
                            immortal[ny][nx]   = True
                            break

        # write back alive
        for y in range(H):
            for x in range(W):
                alive[y][x] = next_alive[y][x]
    
    # if __debug__:                       # runs only if Python -O not used
    #     import inspect, textwrap, sys
    #     print("\n--- life_kernel loaded from:",
    #           sys.modules[life_kernel.__module__].__file__, "---\n")
    #     print(textwrap.dedent(inspect.getsource(life_kernel)))

# =============================================================================
# Core simulation
# =============================================================================

class GOLKeyCore:
    """Grid simulation independent of rendering or RL plumbing."""

    def __init__(self, target, shape=(32, 32), alive_p=(0.3, 0.7), seed=None):
        if not (2 <= len(target) <= 16):
            raise ValueError("Target length must be 2‑16 characters")
        self.rng = np.random.default_rng(seed)
        self.H, self.W = shape
        self.target = target.lower()
        self.alive_lo, self.alive_hi = alive_p

        self.alive = np.zeros(shape, dtype=bool)
        self.immortal = np.zeros(shape, dtype=bool)
        self.chars = np.full(shape, '', dtype='<U1')
        self.chars_idx = np.full(shape, -1, dtype=np.int8)
        self.prefix_len = np.zeros(shape, dtype=np.uint8)
        self.age = np.zeros(shape, dtype=np.uint8)
        self.generation = 0

    # ---------------------------------------------------------------- public
    def reset(self):
        self.random_board(self.alive_lo)
        self.chars_idx.fill(-1)
        self.generation = 0
    
    def step(self, typed_char: str | None = None):
        if typed_char is None:           # ␠ / no‑op
            typed_idx = -1
        else:                            # a‑z or space
            if typed_char not in LETTERS:
                raise ValueError(f"invalid key: {typed_char!r}")
            typed_idx = LETTERS.index(typed_char)
        first_idx = LETTERS.index(self.target[0])
        tgt_arr   = np.frombuffer(self.target.encode(), dtype=np.uint8) - 97
        if NUMBA_OK:
            life_kernel(
                self.alive, self.immortal, self.chars_idx,
                self.prefix_len, self.age,
                typed_idx, first_idx, tgt_arr,
            )
            letter_lookup = np.array(list(LETTERS), dtype='<U1')
            self.chars[:] = np.where(
            self.chars_idx >= 0,
            letter_lookup[self.chars_idx],
            ''
            )
        else:
            self._slow_step(typed_char)
        self.generation += 1

    def _slow_step(self, typed_char=None):
        """Advance one tick. *typed_char* must be in LETTERS or None."""
        # ── classic Life update ─────────────────────────────────────
        neigh = sum(
            np.roll(np.roll(self.alive, dy, 0), dx, 1)
            for dy in (-1, 0, 1)
            for dx in (-1, 0, 1)
            if not (dx == 0 and dy == 0)
        )
        birth    = (~self.alive) & (neigh == 3)
        survive  =  self.alive  & ((neigh == 2) | (neigh == 3))
        next_alive = survive | birth | self.immortal

        next_age = self.age + 1
        next_age[~next_alive] = 0
        next_age[birth] = 0
        next_chars     = self.chars.copy()
        next_prefix    = self.prefix_len.copy()
        next_immortal  = self.immortal.copy()
        next_chars_idx = self.chars_idx.copy()

        # ── assign character to newborns ────────────────────────────
        if typed_char is not None and typed_char in LETTERS:
            next_chars[birth] = typed_char
            if typed_char == self.target[0]:
                next_chars_idx[birth] = LETTERS.index(typed_char)

        # ── clear info for ordinary deaths ──────────────────────────
        died = (~next_alive) & self.alive & (~self.immortal)
        next_chars_idx[died]   = -1
        next_prefix[died]  = 0

        # ── prefix‑extension & immortality logic ────────────────────
        if typed_char is not None:
            ys, xs = np.nonzero(next_alive & (next_chars != ''))
            for y, x in zip(ys.tolist(), xs.tolist()):
                ch  = next_chars[y, x]
                pre = next_prefix[y, x]

                # skip cells that already completed the word
                if pre == len(self.target):
                    next_immortal[y, x] = True
                    continue

                for dy, dx in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    ny, nx = (y + dy) % self.H, (x + dx) % self.W
                    if not next_alive[ny, nx]:
                        continue
                    n_pre = next_prefix[ny, nx]
                    n_ch  = next_chars[ny, nx]

                    # Case A: neighbour has prefix k, I match target[k]  →  I become k+1
                    if n_pre and n_pre < len(self.target) and ch == self.target[n_pre]:
                        next_prefix[y, x]   = n_pre + 1
                        next_immortal[y, x] = True
                        next_immortal[ny, nx] = True
                        break

                    # Case B: I have prefix k, neighbour char matches target[k] → neighbour k+1 
                    #  (we only want this to be the case for the first char)
                    if pre and pre == 1 and n_ch == self.target[pre]:
                        next_prefix[ny, nx] = pre + 1
                        next_immortal[y, x] = True
                        next_immortal[ny, nx] = True
                        break

        # ── commit ─────────────────────────────────────────────────
        self.alive       = next_alive
        self.chars       = next_chars
        self.prefix_len  = next_prefix
        self.immortal    = next_immortal
        self.age         = next_age
        self.chars_idx   = next_chars_idx
        self.generation += 1

    #----------------------------------------------------------------

    def clear_board(self):
        """Erase every live/immortal cell but **keep** generation counter.
        Characters, prefix‑lengths and ages are also zeroed.
        (Used by the viewer’s *soft‑clear* “c” key.)"""
        self.alive.fill(False)
        self.immortal.fill(False)
        self.chars.fill('')
        self.prefix_len.fill(0)
        self.age.fill(0)
    
    def random_board(self, p_alive: float | None = None):
        pa = self.alive_lo if p_alive is None else p_alive
        self.alive[:] = self.rng.random((self.H, self.W)) < pa
        self.immortal.fill(False)
        self.chars.fill('')
        self.prefix_len.fill(0)
        self.age.fill(0)


    def longest_prefix(self):
        return int(self.prefix_len.max(initial=0))

    def done(self):
        return self.longest_prefix() == len(self.target)

# =============================================================================
# Rendering
# =============================================================================


def render_rgb(core, cell_size: int = 16) -> np.ndarray:
    """
    Fast 512×512 viewer‑style render with per‑cell characters and
    age‑based colors.  Uses Pillow only once at the very end.
    """
    H, W      = core.H, core.W

    # --- color by age -------------------------------------------
    age_idx = np.minimum(core.age, len(_COLORS)-1)
    img = _COLORS[age_idx]                    # (H,W,3)
    img[~core.alive] = _BG

    # --- upscale once (adds grid implicitly) ---------------------
    img = np.kron(img, np.ones((cell_size, cell_size, 1), np.uint8))

    # --- draw characters -----------------------------------------
    if np.any(core.chars):
        from PIL import Image, ImageDraw, ImageFont
        pil  = Image.fromarray(img)
        draw = ImageDraw.Draw(pil)

        ys, xs = np.nonzero(core.chars != '')
        for y, x in zip(ys.tolist(), xs.tolist()):
            ch = core.chars[y, x]
            # choose white or black for contrast
            r, g, b = _COLORS[min(core.age[y, x], len(_COLORS)-1)]
            lum = 0.299*r + 0.587*g + 0.114*b
            txt_col = (255, 255, 255) if lum < 128 else (0, 0, 0)
            draw.text(
                (x*cell_size + 3, y*cell_size + 1),
                ch,
                font=_DEFAULT_FONT,
                fill=txt_col
            )

        img = np.asarray(pil, dtype=np.uint8)

    return img

def fast_render_rgb(core, cell_px: int = 16) -> np.ndarray:
    """
    Pillow‑free 512×512 viewer with age colors **and** per‑cell characters.
    Returns (H*px, W*px, 3) uint8 ready for VLM.
    """
    H, W = core.H, core.W

    # -------- base colors: alive‑age vs dead ----------------------
    age_idx = np.minimum(core.age, len(_COLORS) - 1)
    img = _COLORS[age_idx]                       # (H,W,3)
    img[~core.alive] = _BG
    img = np.kron(img, np.ones((cell_px, cell_px, 1), np.uint8))

    # -------- draw characters with NumPy only ----------------------
    if np.any(core.chars):
        ys, xs = np.nonzero(core.chars != '')
        for y, x in zip(ys.tolist(), xs.tolist()):
            ch = core.chars[y, x]
            bm = _GLYPHS.get(ch)
            if bm is None:
                continue
            gh, gw = bm.shape
            y0 = y * cell_px + (cell_px - gh) // 2
            x0 = x * cell_px + (cell_px - gw) // 2

            # high‑contrast foreground colour
            r, g, b = img[y * cell_px, x * cell_px]
            lum = 0.299 * r + 0.587 * g + 0.114 * b
            fg = np.array([255, 255, 255], np.uint8) if lum < 128 else np.array([0, 0, 0], np.uint8)

            patch = img[y0 : y0 + gh, x0 : x0 + gw]
            patch[bm] = fg

    return img



class GOLKeyPixelEnv(gym.Env):
    metadata = {"render_modes": ["rgb_array"]}

    # ───────── action indices ──────────────────────────────────────────
    IDX_LETTER = list(range(26))          # 0‑25  a‑z
    IDX_SPACE  = 26                       # 26    “ ”
    IDX_FLAG   = 27                       # 27    raise‑flag / guess
    IDX_BACK   = 28                       # 28    ←
    IDX_FWD    = 29                       # 29    →
    IDX_CLEAR  = 30                       # 30    wipe grid
    IDX_RANDOM = 31                       # 31    new random soil

    def __init__(self, target="hello", shape=(32, 32), *, agent_instance=None,
                 max_steps=2048, reward_cfg=None, seed=None,
                 cell_px: int = 16, rewind_depth: int = 64):
        super().__init__()

        # ---------- core and buffers ----------------------------------
        self.core       = GOLKeyCore(target, shape, seed=seed)
        self.cell_px    = cell_px
        self.max_steps  = max_steps
        self.history    = deque(maxlen=rewind_depth)   # ← past states
        self.redo_buf   = []                           # → future states

        # ---------- spaces -------------------------------------------
        H, W = shape
        self.observation_space = spaces.Box(
            low=0, high=255,
            shape=(H * cell_px, W * cell_px, 3),
            dtype=np.uint8,
        )
        self.action_space = spaces.Discrete(32)        # ←  0 … 31
        self.vlm_agent = agent_instance
        if self.vlm_agent is None:
            print("WARN: GOLKeyPixelEnv initialized without agent instance for guessing.")

        # ---------- reward knobs -------------------------------------
        cfg = reward_cfg or {}
        self.rw_step    = cfg.get("step_penalty", -1/len(target)/20)
        self.rw_prefix  = cfg.get("prefix_bonus", 1/len(target)/2)
        self.rw_str_done = cfg.get("str_done", 0.5)
        self.rw_timely_attempt = cfg.get("timely_attempt", 0.5)
        self.rw_success = cfg.get("success", 1.0)
        self.rw_fail    = cfg.get("fail",    -1.0)

        self.step_count  = 0
        self.last_prefix  = 0
        self.str_complete = False

    # =================================================================
    #  reset
    # =================================================================
    def reset(self, *, seed=None, options=None, new_target=None):
        super().reset(seed=seed)
        if new_target:
            self.core.target = new_target
        self.core.reset()
        self.history.clear()
        self.redo_buf.clear()
        self.step_count  = 0
        self.last_prefix  = 0
        self.str_complete = False
        return (
            self._obs(),
            {"reward": 0.0, "term": False, "trunc": False, "prefix": 0, "generation": 0, "steps": 0},
        )

    # =================================================================
    #  step
    # =================================================================
    def step(self, action: int, *, guess: str | None = None):
        if not self.action_space.contains(action):
            raise ValueError("invalid action")

        terminated = truncated = False
        reward     = self.rw_step            # every action costs something
        guess_correct = None

        # ─────────────────── time‑travel  ← / → ────────────────────
        if action == self.IDX_BACK:
            if self.history:
                state_before_rewind = self._snap()
                self.redo_buf.append(state_before_rewind)
                prefix_before_rewind = self.last_prefix

                saved_state_dict = self.history.pop()
                self._restore(saved_state_dict)

                was_complete_before_rewind = state_before_rewind["str_complete"]
                is_complete_after_rewind = self.str_complete

                prefix_after_rewind = self.last_prefix

                if was_complete_before_rewind and not is_complete_after_rewind:
                    reward -= self.rw_str_done
                
                if prefix_before_rewind > prefix_after_rewind:
                    prefix_diff = prefix_before_rewind - prefix_after_rewind
                    penalty = self.rw_prefix * prefix_diff
                    reward -= penalty

        elif action == self.IDX_FWD:
            if self.redo_buf:
                self.history.append(self._snap())
                self._restore(self.redo_buf.pop())

        # ─────────────────── CLEAR & RANDOM ─────────────────────────
        elif action == self.IDX_CLEAR:
            penalty_for_lost_state = 0
            if self.str_complete:
                penalty_for_lost_state += self.rw_str_done
            if self.last_prefix > 0:
                penalty_for_lost_state += self.rw_prefix * self.last_prefix
            reward -= penalty_for_lost_state
            self.history.append(self._snap())
            self.redo_buf.clear()
            self._clear_board()

        elif action == self.IDX_RANDOM:
            penalty_for_lost_state = 0
            if self.str_complete:
                penalty_for_lost_state += self.rw_str_done
            if self.last_prefix > 0:
                penalty_for_lost_state += self.rw_prefix * self.last_prefix
            reward -= penalty_for_lost_state
            self.history.append(self._snap())
            self.redo_buf.clear()
            self._random_board()

        # ─────────────────── FLAG (guess) ─────────────────────────── 
        # make sure that there is not an occurence of flagging and then guessing on the next step
        elif action == self.IDX_FLAG:
            terminated = True
            generated_guess = "" if guess is None else guess
            target_len = len(self.core.target)
            if self.vlm_agent:
                try:
                    current_obs_for_guess = self._obs()
                    current_obs_for_guess_tensor = torch.from_numpy(
                        current_obs_for_guess
                    ).permute(2, 0, 1).to(self.vlm_agent.device)
                    generated_guess = self.vlm_agent.guess_word(current_obs_for_guess_tensor, target_len=target_len)
                except Exception as e:
                    print(f"ERROR generating guess inside of env step: {e}")
                
            guess_correct = generated_guess.lower() == self.core.target
            guess_attempted_after_str = self.str_complete
            if guess_attempted_after_str:
                reward += self.rw_timely_attempt
            else:
                reward -= self.rw_timely_attempt
            reward += self.rw_success if guess_correct else self.rw_fail

        # ─────────────────── LETTER / SPACE / NO‑OP ─────────────────
        else:
            self.history.append(self._snap())
            self.redo_buf.clear()

            prefix_before_step = self.last_prefix
            was_complete_before_step = self.str_complete

            typed = None if action == self.IDX_SPACE else LETTERS[action]
            self.core.step(typed)

            prefix_after_step = self.core.longest_prefix()
            is_complete_after_step = self.core.done()

            self.last_prefix = prefix_after_step

            if prefix_after_step > prefix_before_step:
                reward += self.rw_prefix * (prefix_after_step - prefix_before_step)

            if is_complete_after_step and not was_complete_before_step:
                reward += self.rw_str_done
                self.str_complete = True

        # ─────────────────── bookkeeping / truncation ───────────────
        self.step_count += 1
        if self.step_count >= self.max_steps:
            truncated = True

        return self._finish_step(reward, guess_correct, action, terminated, truncated)

    # =================================================================
    #  helpers
    # =================================================================
    def _snap(self):
        c = self.core
        return dict(
            alive=c.alive.copy(), immortal=c.immortal.copy(),
            chars=c.chars.copy(), prefix=c.prefix_len.copy(),
            age=c.age.copy(), gen=c.generation,
            str_complete=self.str_complete
        )

    def _restore(self, s):
        c = self.core
        c.alive[:]      = s["alive"]
        c.immortal[:]   = s["immortal"]
        c.chars[:]      = s["chars"]
        c.prefix_len[:] = s["prefix"]
        c.age[:]        = s["age"]
        c.generation    = s["gen"]
        self.str_complete = s["str_complete"]
        self.last_prefix = c.longest_prefix()

    # -------- board utils -------------------------------------------
    def _clear_board(self):
        """Set every cell dead & empty; generation continues."""
        self.core.clear_board()
        self.last_prefix = 0

    def _random_board(self):
        """Re‑seed life with 50 % probability, no characters."""
        self.core.random_board()
        self.last_prefix = 0

    # -------- obs / finish -----------------------------------------
    def _obs(self):
        return fast_render_rgb(self.core, cell_px=self.cell_px)

    def _finish_step(self, reward, guess_correct, action, term, trunc):
        info = {
                "reward":     float(reward),
                "terminated": term,
                "truncated":  trunc,
                "prefix":     self.last_prefix,
                "generation": self.core.generation,
                "steps":      self.step_count,
            }
        if term:
            if guess_correct is None:
                guess_correct = False
            info['success'] = guess_correct
            info['action_taken'] = action
        return (
            self._obs(),
            float(reward),
            term,
            trunc,
            info
        )
